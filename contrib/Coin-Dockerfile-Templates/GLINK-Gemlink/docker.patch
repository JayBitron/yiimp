diff --git a/src/main.cpp b/src/main.cpp
index cc05da9..1077834 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -4292,7 +4292,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const CChainParams
 //     return true;
 // }
 
-bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex* const pindexPrev)
+bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex* const pindexPrev, bool isNewBlock = false)
 {
     const Consensus::Params& consensusParams = chainparams.GetConsensus();
     uint256 hash = block.GetHash();
@@ -4327,9 +4327,11 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta
 
     // check block timestamp
     if (chainparams.GetConsensus().NetworkUpgradeActive(nHeight, Consensus::UPGRADE_WAKANDA)) {
-        if (!CheckBlockTimestamp(pindexPrev, &block)) {
-            return state.Invalid(error("%s: new block is too fast", __func__),
+        if (!isNewBlock) {
+            if (!CheckBlockTimestamp(pindexPrev, &block)) {
+        	return state.Invalid(error("%s: new block is too fast", __func__),
                                  REJECT_TIME_TOO_FAST, "block-too-fast");
+	    }
         }
     }
     return true;
@@ -4639,7 +4641,7 @@ bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams,
     auto verifier = ProofVerifier::Disabled();
 
     // NOTE: CheckBlockHeader is called by CheckBlock
-    if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev))
+    if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, true))
         return false;
     if (!CheckBlock(block, state, chainparams, verifier, fCheckPOW, fCheckMerkleRoot))
         return false;
diff --git a/src/main.h b/src/main.h
index 1a1378e..112f5a3 100644
--- a/src/main.h
+++ b/src/main.h
@@ -874,9 +874,11 @@ bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, const
 bool CheckBlock(const CBlock& block, CValidationState& state, const CChainParams& chainparams, ProofVerifier& verifier, bool fCheckPOW = true, bool fCheckMerkleRoot = true);
 
 /** Context-dependent validity checks */
-bool ContextualCheckBlockHeader(const CBlockHeader& block, const CChainParams& chainparams, CValidationState& state, CBlockIndex* pindexPrev);
+bool ContextualCheckBlockHeader(const CBlockHeader& block, const CChainParams& chainparams, CValidationState& state, CBlockIndex* pindexPrev, bool isNewBlock);
 bool ContextualCheckBlock(const CBlock& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexPrev);
 
+bool CheckBlockTimestamp(const CBlockIndex* pindexLast, const CBlockHeader *pblock);
+
 /** Check a block is completely valid from start to finish (only works on top of our current best block, with cs_main held) */
 bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams, const CBlock& block, CBlockIndex* pindexPrev, bool fCheckPOW = true, bool fCheckMerkleRoot = true);
 
diff --git a/src/rpc/mining.cpp b/src/rpc/mining.cpp
index 42662dc..6dc2278 100644
--- a/src/rpc/mining.cpp
+++ b/src/rpc/mining.cpp
@@ -538,6 +538,8 @@ UniValue getblocktemplate(const UniValue& params, bool fHelp)
     result.push_back(Pair("height", (int64_t)(pindexPrev->nHeight + 1)));
     result.push_back(Pair("votes", aVotes));
 
+    result.push_back(Pair("mining_disabled", (!CheckBlockTimestamp(pindexPrev , pblock))? true : false ));
+
     if (pblock->payee != CScript()) {
         CTxDestination address1;
         ExtractDestination(pblock->payee, address1);
